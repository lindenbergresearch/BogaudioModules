#include <cstring>
#include "AnalyzerXL.hpp"

#define SMOOTH_KEY "smooth"
#define QUALITY_KEY "quality"
#define QUALITY_GOOD_KEY "good"
#define QUALITY_HIGH_KEY "high"
#define QUALITY_ULTRA_KEY "ultra"
#define QUALITY_ULTRA_ULTRA_KEY "ultra_ultra"
#define WINDOW_KEY "window"
#define WINDOW_NONE_KEY "none"
#define WINDOW_HAMMING_KEY "hamming"
#define WINDOW_KAISER_KEY "kaiser"


void AnalyzerXL::reset() {
    _core.resetChannels();
}


void AnalyzerXL::sampleRateChange() {
    _sampleRate = APP->engine->getSampleRate();
}


json_t *AnalyzerXL::dataToJson() {
    json_t *root = json_object();
    frequencyPlotToJson(root);
    frequencyRangeToJson(root);
    amplitudePlotToJson(root);
    json_object_set_new(root, SMOOTH_KEY, json_real(_smooth));

    switch (_quality) {
        case AnalyzerCore::QUALITY_GOOD: {
            json_object_set_new(root, QUALITY_KEY, json_string(QUALITY_GOOD_KEY));
            break;
        }
        case AnalyzerCore::QUALITY_HIGH: {
            json_object_set_new(root, QUALITY_KEY, json_string(QUALITY_HIGH_KEY));
            break;
        }
        case AnalyzerCore::QUALITY_ULTRA: {
            json_object_set_new(root, QUALITY_KEY, json_string(QUALITY_ULTRA_KEY));
            break;
        }
        case AnalyzerCore::QUALITY_ULTRA_ULTRA: {
            json_object_set_new(root, QUALITY_KEY, json_string(QUALITY_ULTRA_ULTRA_KEY));
            break;
        }
        default:;
    }

    switch (_window) {
        case AnalyzerCore::WINDOW_NONE: {
            json_object_set_new(root, WINDOW_KEY, json_string(WINDOW_NONE_KEY));
            break;
        }
        case AnalyzerCore::WINDOW_HAMMING: {
            json_object_set_new(root, WINDOW_KEY, json_string(WINDOW_HAMMING_KEY));
            break;
        }
        case AnalyzerCore::WINDOW_KAISER: {
            json_object_set_new(root, WINDOW_KEY, json_string(WINDOW_KAISER_KEY));
            break;
        }
    }

    if (root) return root;
    else return BGModule::dataToJson();
}


void AnalyzerXL::dataFromJson(json_t *root) {
    BGModule::dataFromJson(root);
    frequencyPlotFromJson(root);
    frequencyRangeFromJson(root);
    amplitudePlotFromJson(root);

    json_t *js = json_object_get(root, SMOOTH_KEY);
    if (js) {
        _smooth = clamp(json_real_value(js), 0.0f, 0.5f);
    }

    json_t *jq = json_object_get(root, QUALITY_KEY);
    if (jq) {
        const char *s = json_string_value(jq);
        if (strcmp(s, QUALITY_GOOD_KEY) == 0) {
            _quality = AnalyzerCore::QUALITY_GOOD;
        } else if (strcmp(s, QUALITY_HIGH_KEY) == 0) {
            _quality = AnalyzerCore::QUALITY_HIGH;
        } else if (strcmp(s, QUALITY_ULTRA_KEY) == 0) {
            _quality = AnalyzerCore::QUALITY_ULTRA;
        } else if (strcmp(s, QUALITY_ULTRA_ULTRA_KEY) == 0) {
            _quality = AnalyzerCore::QUALITY_ULTRA_ULTRA;
        }
    }

    json_t *jw = json_object_get(root, WINDOW_KEY);
    if (jw) {
        const char *s = json_string_value(jw);
        if (strcmp(s, WINDOW_NONE_KEY) == 0) {
            _window = AnalyzerCore::WINDOW_NONE;
        } else if (strcmp(s, WINDOW_HAMMING_KEY) == 0) {
            _window = AnalyzerCore::WINDOW_HAMMING;
        } else if (strcmp(s, WINDOW_KAISER_KEY) == 0) {
            _window = AnalyzerCore::WINDOW_KAISER;
        }
    }

    BGModule::dataFromJson(root);
}


void AnalyzerXL::modulate() {
    _rangeMinHz = 0.0f;
    _rangeMaxHz = 0.5f * _sampleRate;
    if (_range < 0.0f) {
        _rangeMaxHz *= 1.0f + _range;
    } else if (_range > 0.0f) {
        _rangeMinHz = _range * _rangeMaxHz;
    }

    float smooth = _smooth / (_core.size() / (_core._overlap * _sampleRate));
    int averageN = std::max(1, (int) roundf(smooth));
    _core.setParams(_sampleRate, averageN, _quality, _window);
}


void AnalyzerXL::processAll(const ProcessArgs &args) {
    for (int i = 0; i < 4; ++i) {
        _core.stepChannel(i, inputs[SIGNAL_A_INPUT + i]);
    }
}


struct AnalyzerXLWidget : AnalyzerBaseWidget {
    // width
    static constexpr int HP_START = 60;
    static constexpr float DEFAULT_HEIGHT = 378;

    Vec inset = Vec(190, 0);
    int currentHP = HP_START;
    AnalyzerDisplay *display;

    explicit AnalyzerXLWidget(AnalyzerXL *module) {
        setModule(module);
        box.size = Vec(RACK_GRID_WIDTH * HP_START, RACK_GRID_HEIGHT);
        setPanel(box.size, "AnalyzerXL", false);

        auto size = Vec(box.size.x - inset.x - 1, DEFAULT_HEIGHT);
        display = new AnalyzerDisplay(module, size, false);
        display->setPosition(inset);
        display->setSize(size);
        addChild(display);

        display->setModuleWidget(this);

        // generated by svg_widgets.rb
        auto signalaInputPosition = Vec(26.2, 62);
        auto signalbInputPosition = Vec(26.2, 110);
        auto signalcInputPosition = Vec(26.2, 158);
        auto signaldInputPosition = Vec(26.2, 206);

        addInput(createInputCentered<Port24>(signalaInputPosition, module, AnalyzerXL::SIGNAL_A_INPUT));
        addInput(createInputCentered<Port24>(signalbInputPosition, module, AnalyzerXL::SIGNAL_B_INPUT));
        addInput(createInputCentered<Port24>(signalcInputPosition, module, AnalyzerXL::SIGNAL_C_INPUT));
        addInput(createInputCentered<Port24>(signaldInputPosition, module, AnalyzerXL::SIGNAL_D_INPUT));

        addParam(createParamCentered<Knob26>(signalaInputPosition.plus(Vec(45.8, 3.8)), module, AnalyzerXL::CONTROL_A_PARAM));
        addParam(createParamCentered<Knob26>(signalbInputPosition.plus(Vec(45.8, 3.8)), module, AnalyzerXL::CONTROL_B_PARAM));
        addParam(createParamCentered<Knob26>(signalcInputPosition.plus(Vec(45.8, 3.8)), module, AnalyzerXL::CONTROL_C_PARAM));
        addParam(createParamCentered<Knob26>(signaldInputPosition.plus(Vec(45.8, 3.8)), module, AnalyzerXL::CONTROL_D_PARAM));

        addParam(createParamCentered<SliderSwitch2State14>(signalaInputPosition.plus(Vec(45.8 + 34, 3.1)), module, AnalyzerXL::SWITCH_A_DC_PARAM));
        addParam(createParamCentered<SliderSwitch2State14>(signalbInputPosition.plus(Vec(45.8 + 34, 3.1)), module, AnalyzerXL::SWITCH_B_DC_PARAM));
        addParam(createParamCentered<SliderSwitch2State14>(signalcInputPosition.plus(Vec(45.8 + 34, 3.1)), module, AnalyzerXL::SWITCH_C_DC_PARAM));
        addParam(createParamCentered<SliderSwitch2State14>(signaldInputPosition.plus(Vec(45.8 + 34, 3.1)), module, AnalyzerXL::SWITCH_D_DC_PARAM));

        addParam(createParamCentered<Knob26>(Vec(26.2, 269.46), module, AnalyzerXL::CONTROL_LINE_THICKNESS_PARAM));
        addParam(createParamCentered<Knob26>(Vec(72.0, 269.46), module, AnalyzerXL::CONTROL_COLOR_PARAM));
        addParam(createParamCentered<Knob26>(Vec(118.0, 269.46), module, AnalyzerXL::CONTROL_XXX_PARAM));

        addParam(createParamCentered<SliderSwitch2State14>(Vec(20.2, 322.0), module, AnalyzerXL::SWITCH_NVG_LIGHTER_PARAM));
        addParam(createParamCentered<SliderSwitch2State14>(Vec(66.0, 322.0), module, AnalyzerXL::SWITCH_AVERAGE_PARAM));
        addParam(createParamCentered<SliderSwitch2State14>(Vec(112.0, 322.0), module, AnalyzerXL::SWITCH_CABLE_COLOR_PARAM));
    }

    void resizeDisplay(float width) {
        currentHP = int(width / RACK_GRID_WIDTH);
        auto size = Vec(RACK_GRID_WIDTH * float(currentHP), RACK_GRID_HEIGHT);
        auto displaySize = Vec(size.x - inset.x - 1, DEFAULT_HEIGHT);

        setSize(size); // widget
        display->setNewSize(displaySize);
        display->setPosition(inset); // offset
    }

    void step() override {
        Widget::step();
    }

    void onDragStart(const DragStartEvent &e) override {
        ModuleWidget::onDragStart(e);
        DEBUG("this=%p onDragStart %d %p", this, e.button, e.getTarget());
    }

    void onDragEnd(const DragEndEvent &e) override {
        ModuleWidget::onDragEnd(e);
        DEBUG("this=%p onDragEnd %d %p", this, e.button, e.getTarget());

    }

    void onDragMove(const DragMoveEvent &e) override {
        ModuleWidget::onDragMove(e);

        DEBUG("this=%p onDragMove %d %p mouse %.2f %.2f", this, e.button, e.getTarget(), e.mouseDelta.x, e.mouseDelta.y);

    }

    void onDragHover(const DragHoverEvent &e) override {
        ModuleWidget::onDragHover(e);

        if (e.mouseDelta.isZero()) return;

        auto pos = APP->scene->getMousePos() - box.pos;
        DEBUG("this=%p onDragHover %d %p mouse (%.1f %.1f) (%.1f %.1f)", this, e.button, e.getTarget(), e.mouseDelta.x, e.mouseDelta.y, pos.x, pos.y);

    }

    void contextMenu(Menu *menu) override {
        auto a = dynamic_cast<AnalyzerXL *>(module);
        assert(a);

        menu->addChild(new MenuLabel());
        addFrequencyPlotContextMenu(menu);
        addFrequencyRangeContextMenu(menu);
        addAmplitudePlotContextMenu(menu);
        {
            auto *mi = new OptionsMenuItem("Smoothing");
            mi->addItem(OptionMenuItem("None", [a]() { return a->_smooth == 0.0f; }, [a]() { a->_smooth = 0.0f; }));
            mi->addItem(OptionMenuItem("10ms", [a]() { return a->_smooth == 0.01f; }, [a]() { a->_smooth = 0.01f; }));
            mi->addItem(OptionMenuItem("50ms", [a]() { return a->_smooth == 0.05f; }, [a]() { a->_smooth = 0.05f; }));
            mi->addItem(OptionMenuItem("100ms", [a]() { return a->_smooth == 0.1f; }, [a]() { a->_smooth = 0.1f; }));
            mi->addItem(OptionMenuItem("250ms", [a]() { return a->_smooth == 0.25f; }, [a]() { a->_smooth = 0.25f; }));
            mi->addItem(OptionMenuItem("500ms", [a]() { return a->_smooth == 0.5f; }, [a]() { a->_smooth = 0.5f; }));
            mi->addItem(OptionMenuItem("1000ms", [a]() { return a->_smooth == 1.0f; }, [a]() { a->_smooth = 1.0f; }));
            mi->addItem(OptionMenuItem("1500ms", [a]() { return a->_smooth == 1.5f; }, [a]() { a->_smooth = 1.5f; }));
            mi->addItem(OptionMenuItem("3000ms", [a]() { return a->_smooth == 3.0f; }, [a]() { a->_smooth = 3.0f; }));
            OptionsMenuItem::addToMenu(mi, menu);
        }
        {
            auto *mi = new OptionsMenuItem("Quality");
            mi->addItem(OptionMenuItem("Good", [a]() { return a->_quality == AnalyzerCore::QUALITY_GOOD; }, [a]() { a->_quality = AnalyzerCore::QUALITY_GOOD; }));
            mi->addItem(OptionMenuItem("High", [a]() { return a->_quality == AnalyzerCore::QUALITY_HIGH; }, [a]() { a->_quality = AnalyzerCore::QUALITY_HIGH; }));
            mi->addItem(OptionMenuItem("Ultra", [a]() { return a->_quality == AnalyzerCore::QUALITY_ULTRA; }, [a]() { a->_quality = AnalyzerCore::QUALITY_ULTRA; }));
            mi->addItem(OptionMenuItem("Ultra+", [a]() { return a->_quality == AnalyzerCore::QUALITY_ULTRA_ULTRA; }, [a]() { a->_quality = AnalyzerCore::QUALITY_ULTRA_ULTRA; }));
            OptionsMenuItem::addToMenu(mi, menu);
        }
        {
            auto *mi = new OptionsMenuItem("Window");
            mi->addItem(OptionMenuItem("Kaiser", [a]() { return a->_window == AnalyzerCore::WINDOW_KAISER; }, [a]() { a->_window = AnalyzerCore::WINDOW_KAISER; }));
            mi->addItem(OptionMenuItem("Hamming", [a]() { return a->_window == AnalyzerCore::WINDOW_HAMMING; }, [a]() { a->_window = AnalyzerCore::WINDOW_HAMMING; }));
            mi->addItem(OptionMenuItem("None", [a]() { return a->_window == AnalyzerCore::WINDOW_NONE; }, [a]() { a->_window = AnalyzerCore::WINDOW_NONE; }));
            OptionsMenuItem::addToMenu(mi, menu);
        }
    }
};


auto *modelAnalyzerXL = rack::createModel<AnalyzerXL, AnalyzerXLWidget>("DSA4");
